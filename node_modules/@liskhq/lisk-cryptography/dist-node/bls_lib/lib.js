"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blsPopVerify = exports.blsPopProve = exports.blsFastAggregateVerify = exports.blsAggregateVerify = exports.blsVerify = exports.blsSign = exports.blsAggregate = exports.blsSkToPk = exports.isMultipleOfGroupOrder = exports.blsKeyGen = exports.blsKeyValidate = void 0;
const blst_1 = require("@chainsafe/blst");
const bindings_1 = require("@chainsafe/blst/dist/bindings");
const crypto_1 = require("crypto");
const DST_POP = 'BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_';
const blsKeyValidate = (pk) => {
    try {
        const key = blst_1.PublicKey.fromBytes(pk);
        key.keyValidate();
        return true;
    }
    catch {
        return false;
    }
};
exports.blsKeyValidate = blsKeyValidate;
const blsKeyGen = (ikm) => Buffer.from(blst_1.SecretKey.fromKeygen(ikm).toBytes());
exports.blsKeyGen = blsKeyGen;
const groupOrder = Buffer.from('73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001', 'hex');
const groupOrderDouble = Buffer.from('e7db4ea6533afa906673b0101343b00aa77b4805fffcb7fdfffffffe00000002', 'hex');
const isMultipleOfGroupOrder = (sk) => {
    const equalToGroupOrder = (0, crypto_1.timingSafeEqual)(sk, groupOrder);
    const equalToDoubleGroupOrder = (0, crypto_1.timingSafeEqual)(sk, groupOrderDouble);
    return equalToGroupOrder || equalToDoubleGroupOrder;
};
exports.isMultipleOfGroupOrder = isMultipleOfGroupOrder;
const blsSkToPk = (sk) => {
    if ((0, exports.isMultipleOfGroupOrder)(sk)) {
        throw new Error('Secret key is not valid.');
    }
    const secretKey = blst_1.SecretKey.fromBytes(sk);
    return Buffer.from(secretKey.toPublicKey().toBytes());
};
exports.blsSkToPk = blsSkToPk;
const blsAggregate = (signatures) => {
    try {
        return Buffer.from((0, blst_1.aggregateSignatures)(signatures.map(s => blst_1.Signature.fromBytes(s))).toBytes());
    }
    catch {
        return false;
    }
};
exports.blsAggregate = blsAggregate;
const blsSign = (sk, message) => {
    if ((0, exports.isMultipleOfGroupOrder)(sk)) {
        throw new Error('Secret key is not valid.');
    }
    const secretKey = blst_1.SecretKey.fromBytes(sk);
    return Buffer.from(secretKey.sign(message).toBytes());
};
exports.blsSign = blsSign;
const blsVerify = (pk, message, signature) => {
    try {
        const sig = blst_1.Signature.fromBytes(signature);
        const pub = blst_1.PublicKey.fromBytes(pk);
        return (0, blst_1.verify)(message, pub, sig);
    }
    catch {
        return false;
    }
};
exports.blsVerify = blsVerify;
const blsAggregateVerify = (publicKeys, messages, signature) => {
    if (publicKeys.length === 0)
        return false;
    try {
        return (0, blst_1.aggregateVerify)(messages.map(m => m), publicKeys.map(k => blst_1.PublicKey.fromBytes(k)), blst_1.Signature.fromBytes(signature));
    }
    catch {
        return false;
    }
};
exports.blsAggregateVerify = blsAggregateVerify;
const blsFastAggregateVerify = (publicKeys, messages, signature) => {
    if (publicKeys.length === 0)
        return false;
    try {
        return (0, blst_1.fastAggregateVerify)(messages, publicKeys.map(k => blst_1.PublicKey.fromBytes(k)), blst_1.Signature.fromBytes(signature));
    }
    catch {
        return false;
    }
};
exports.blsFastAggregateVerify = blsFastAggregateVerify;
const blsPopProve = (sk) => {
    const message = (0, exports.blsSkToPk)(sk);
    const sig = new bindings_1.blst.P2();
    if ((0, exports.isMultipleOfGroupOrder)(sk)) {
        throw new Error('Secret key is not valid.');
    }
    const secretKey = blst_1.SecretKey.fromBytes(sk);
    return Buffer.from(new blst_1.Signature(sig.hash_to(message, DST_POP).sign_with(secretKey.value)).toBytes());
};
exports.blsPopProve = blsPopProve;
const blsPopVerify = (pk, proof) => {
    if (!(0, exports.blsKeyValidate)(pk)) {
        return false;
    }
    try {
        const signature = blst_1.Signature.fromBytes(proof, blst_1.CoordType.affine).value;
        const publicKey = blst_1.PublicKey.fromBytes(pk, blst_1.CoordType.affine).value;
        return signature.core_verify(publicKey, true, pk, DST_POP) === bindings_1.BLST_ERROR.BLST_SUCCESS;
    }
    catch {
        return false;
    }
};
exports.blsPopVerify = blsPopVerify;
//# sourceMappingURL=lib.js.map