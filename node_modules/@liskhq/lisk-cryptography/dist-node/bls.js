"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPrivateKeyFromPhraseAndPath = exports.verifyWeightedAggSig = exports.verifyAggSig = exports.createAggSig = exports.verifyData = exports.signData = exports.popProve = exports.popVerify = exports.validateKey = exports.getPublicKeyFromPrivateKey = exports.generatePrivateKey = exports.BLS_SUPPORTED = void 0;
const crypto = require("crypto");
const lisk_passphrase_1 = require("@liskhq/lisk-passphrase");
const bls_lib_1 = require("./bls_lib");
Object.defineProperty(exports, "BLS_SUPPORTED", { enumerable: true, get: function () { return bls_lib_1.BLS_SUPPORTED; } });
const utils_1 = require("./utils");
const constants_1 = require("./constants");
exports.generatePrivateKey = bls_lib_1.blsKeyGen;
exports.getPublicKeyFromPrivateKey = bls_lib_1.blsSkToPk;
exports.validateKey = bls_lib_1.blsKeyValidate;
exports.popVerify = bls_lib_1.blsPopVerify;
exports.popProve = bls_lib_1.blsPopProve;
const readBit = (buf, bit) => {
    const byteIndex = Math.floor(bit / 8);
    const bitIndex = bit % 8;
    return (buf[byteIndex] >> bitIndex) % 2 === 1;
};
const writeBit = (buf, bit, val) => {
    const byteIndex = Math.floor(bit / 8);
    const bitIndex = bit % 8;
    if (val) {
        buf[byteIndex] |= 1 << bitIndex;
    }
    else {
        buf[byteIndex] &= ~(1 << bitIndex);
    }
};
const signData = (tag, chainID, data, privateKey) => (0, bls_lib_1.blsSign)(privateKey, (0, utils_1.hash)((0, utils_1.tagMessage)(tag, chainID, data)));
exports.signData = signData;
const verifyData = (tag, chainID, data, signature, publicKey) => (0, bls_lib_1.blsVerify)(publicKey, (0, utils_1.hash)((0, utils_1.tagMessage)(tag, chainID, data)), signature);
exports.verifyData = verifyData;
const createAggSig = (publicKeysList, pubKeySignaturePairs) => {
    const aggregationBits = Buffer.alloc(Math.ceil(publicKeysList.length / 8));
    const signatures = [];
    for (const pair of pubKeySignaturePairs) {
        signatures.push(pair.signature);
        const index = publicKeysList.findIndex(key => key.equals(pair.publicKey));
        writeBit(aggregationBits, index, true);
    }
    const signature = (0, bls_lib_1.blsAggregate)(signatures);
    if (!signature) {
        throw new Error('Can not aggregate signatures');
    }
    return { aggregationBits, signature };
};
exports.createAggSig = createAggSig;
const verifyAggregationBits = (publicKeysList, aggregationBits) => {
    const expectedAggregationBitsLength = Math.ceil(publicKeysList.length / 8);
    if (aggregationBits.length !== expectedAggregationBitsLength) {
        return false;
    }
    const unusedBits = publicKeysList.length % 8;
    if (unusedBits === 0) {
        return true;
    }
    const lastByte = aggregationBits[aggregationBits.length - 1];
    if (lastByte >> unusedBits !== 0) {
        return false;
    }
    return true;
};
const verifyAggSig = (publicKeysList, aggregationBits, signature, tag, chainID, message) => {
    if (!verifyAggregationBits(publicKeysList, aggregationBits)) {
        return false;
    }
    const taggedMessage = (0, utils_1.tagMessage)(tag, chainID, message);
    const keys = [];
    for (const [index, key] of publicKeysList.entries()) {
        if (readBit(aggregationBits, index)) {
            keys.push(key);
        }
    }
    return (0, bls_lib_1.blsFastAggregateVerify)(keys, (0, utils_1.hash)(taggedMessage), signature);
};
exports.verifyAggSig = verifyAggSig;
const verifyWeightedAggSig = (publicKeysList, aggregationBits, signature, tag, chainID, message, weights, threshold) => {
    if (!verifyAggregationBits(publicKeysList, aggregationBits)) {
        return false;
    }
    const taggedMessage = (0, utils_1.tagMessage)(tag, chainID, message);
    const keys = [];
    let weightSum = BigInt(0);
    for (const [index, key] of publicKeysList.entries()) {
        if (readBit(aggregationBits, index)) {
            keys.push(key);
            weightSum += BigInt(weights[index]);
        }
    }
    if (weightSum < BigInt(threshold)) {
        return false;
    }
    return (0, bls_lib_1.blsFastAggregateVerify)(keys, (0, utils_1.hash)(taggedMessage), signature);
};
exports.verifyWeightedAggSig = verifyWeightedAggSig;
const flipBits = (buf) => Buffer.from(buf.map(x => x ^ 0xff));
const sha256 = (x) => crypto.createHash(constants_1.SHA256).update(x).digest();
const hmacSHA256 = (key, message, hashValue) => crypto.createHmac(hashValue, key).update(message).digest();
const hkdfSHA256 = (ikm, length, salt, info) => {
    if (salt.length === 0) {
        salt = constants_1.EMPTY_SALT;
    }
    const PRK = hmacSHA256(salt, ikm, constants_1.SHA256);
    let t = Buffer.from([]);
    let OKM = Buffer.from([]);
    for (let i = 0; i < Math.ceil(length / constants_1.HASH_LENGTH); i += 1) {
        t = hmacSHA256(PRK, Buffer.concat([t, info, Buffer.from([1 + i])]), constants_1.SHA256);
        OKM = Buffer.concat([OKM, t]);
    }
    return OKM.slice(0, length);
};
const toLamportSK = (IKM, salt) => {
    const info = Buffer.from([]);
    const OKM = hkdfSHA256(IKM, constants_1.L, salt, info);
    const lamportSK = [];
    for (let i = 0; i < 255; i += 1) {
        lamportSK.push(OKM.slice(i * 32, (i + 1) * 32));
    }
    return lamportSK;
};
const parentSKToLamportPK = (parentSK, index) => {
    const salt = Buffer.allocUnsafe(4);
    salt.writeUIntBE(index, 0, 4);
    const IKM = parentSK;
    const hashedLamport0 = toLamportSK(IKM, salt).map(x => sha256(x));
    const hashedLamport1 = toLamportSK(flipBits(IKM), salt).map(x => sha256(x));
    const lamportPK = Buffer.concat(hashedLamport0.concat(hashedLamport1));
    return sha256(lamportPK);
};
const deriveChildSK = (parentSK, index) => {
    const lamportPK = parentSKToLamportPK(parentSK, index);
    return (0, bls_lib_1.blsKeyGen)(lamportPK);
};
const getPrivateKeyFromPhraseAndPath = async (phrase, path) => {
    const masterSeed = await lisk_passphrase_1.Mnemonic.mnemonicToSeed(phrase);
    let key = (0, bls_lib_1.blsKeyGen)(masterSeed);
    for (const segment of (0, utils_1.parseKeyDerivationPath)(path)) {
        key = deriveChildSK(key, segment);
    }
    return key;
};
exports.getPrivateKeyFromPhraseAndPath = getPrivateKeyFromPhraseAndPath;
//# sourceMappingURL=bls.js.map