"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLisk32AddressFromAddress = exports.getAddressFromLisk32Address = exports.validateLisk32Address = exports.getLisk32AddressFromPublicKey = exports.getAddressFromPrivateKey = exports.getAddressFromPublicKey = void 0;
const constants_1 = require("./constants");
const nacl_1 = require("./nacl");
const utils_1 = require("./utils");
const convertUIntArray = (uintArray, fromBits, toBits) => {
    const maxValue = (1 << toBits) - 1;
    let accumulator = 0;
    let bits = 0;
    const result = [];
    for (let p = 0; p < uintArray.length; p += 1) {
        const byte = uintArray[p];
        if (byte < 0 || byte >> fromBits !== 0) {
            return [];
        }
        accumulator = (accumulator << fromBits) | byte;
        bits += fromBits;
        while (bits >= toBits) {
            bits -= toBits;
            result.push((accumulator >> bits) & maxValue);
        }
    }
    return result;
};
const convertUInt5ToBase32 = (uint5Array) => uint5Array.map((val) => constants_1.LISK32_CHARSET[val]).join('');
const getAddressFromPublicKey = (publicKey) => {
    const buffer = (0, utils_1.hash)(publicKey);
    const truncatedBuffer = buffer.slice(0, constants_1.BINARY_ADDRESS_LENGTH);
    if (truncatedBuffer.length !== constants_1.BINARY_ADDRESS_LENGTH) {
        throw new Error(`Lisk address must contain exactly ${constants_1.BINARY_ADDRESS_LENGTH} bytes`);
    }
    return truncatedBuffer;
};
exports.getAddressFromPublicKey = getAddressFromPublicKey;
const getAddressFromPrivateKey = (privateKey) => {
    const publicKey = (0, nacl_1.getPublicKey)(privateKey);
    return (0, exports.getAddressFromPublicKey)(publicKey);
};
exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
const polymod = (uint5Array) => {
    let chk = 1;
    for (const value of uint5Array) {
        const top = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ value;
        for (let i = 0; i < 5; i += 1) {
            if ((top >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};
const createChecksum = (uint5Array) => {
    const values = uint5Array.concat([0, 0, 0, 0, 0, 0]);
    const mod = polymod(values) ^ 1;
    const result = [];
    for (let p = 0; p < 6; p += 1) {
        result.push((mod >> (5 * (5 - p))) & 31);
    }
    return result;
};
const verifyChecksum = (integerSequence) => polymod(integerSequence) === 1;
const addressToLisk32 = (address) => {
    const byteSequence = [];
    for (const b of address) {
        byteSequence.push(b);
    }
    const uint5Address = convertUIntArray(byteSequence, 8, 5);
    const uint5Checksum = createChecksum(uint5Address);
    return convertUInt5ToBase32(uint5Address.concat(uint5Checksum));
};
const getLisk32AddressFromPublicKey = (publicKey, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => `${prefix}${addressToLisk32((0, exports.getAddressFromPublicKey)(publicKey))}`;
exports.getLisk32AddressFromPublicKey = getLisk32AddressFromPublicKey;
const validateLisk32Address = (address, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => {
    if (address.length !== constants_1.LISK32_ADDRESS_LENGTH) {
        throw new Error(`Address length does not match requirements. Expected ${constants_1.LISK32_ADDRESS_LENGTH} characters.`);
    }
    const addressPrefix = address.substring(0, 3);
    if (addressPrefix !== prefix) {
        throw new Error(`Invalid address prefix. Actual prefix: ${addressPrefix}, Expected prefix: ${prefix}`);
    }
    const addressSubstringArray = address.substring(3).split('');
    if (!addressSubstringArray.every(char => constants_1.LISK32_CHARSET.includes(char))) {
        throw new Error(`Invalid character found in address. Only allow characters: '${constants_1.LISK32_CHARSET}'.`);
    }
    const integerSequence = addressSubstringArray.map(char => constants_1.LISK32_CHARSET.indexOf(char));
    if (!verifyChecksum(integerSequence)) {
        throw new Error('Invalid checksum for address.');
    }
    return true;
};
exports.validateLisk32Address = validateLisk32Address;
const getAddressFromLisk32Address = (base32Address, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => {
    (0, exports.validateLisk32Address)(base32Address, prefix);
    const base32AddressNoPrefixNoChecksum = base32Address.substring(prefix.length, base32Address.length - 6);
    const addressArray = base32AddressNoPrefixNoChecksum.split('');
    const integerSequence = addressArray.map(char => constants_1.LISK32_CHARSET.indexOf(char));
    const integerSequence8 = convertUIntArray(integerSequence, 5, 8);
    return Buffer.from(integerSequence8);
};
exports.getAddressFromLisk32Address = getAddressFromLisk32Address;
const getLisk32AddressFromAddress = (address, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => `${prefix}${addressToLisk32(address)}`;
exports.getLisk32AddressFromAddress = getLisk32AddressFromAddress;
//# sourceMappingURL=address.js.map