"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyEncryptedMessage = exports.parseEncryptedMessage = exports.decryptMessageWithPassword = exports.encryptMessageWithPassword = exports.decryptAES128GCMWithPassword = exports.encryptAES128GCMWithPassword = exports.KDF = exports.Cipher = exports.ARGON2_MEMORY = void 0;
const hash_wasm_1 = require("hash-wasm");
const querystring = require("querystring");
const crypto = require("crypto");
const utils_1 = require("./utils");
const PBKDF2_ITERATIONS = 1e6;
const PBKDF2_KEYLEN = 32;
const PBKDF2_HASH_FUNCTION = 'sha256';
const ENCRYPTION_VERSION = '1';
const HASH_LENGTH = 32;
const ARGON2_ITERATIONS = 1;
const ARGON2_PARALLELISM = 4;
exports.ARGON2_MEMORY = 2097023;
const getKeyFromPassword = (password, salt, iterations) => crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);
const getKeyFromPasswordWithArgon2 = async (options) => Buffer.from(await (0, hash_wasm_1.argon2id)({
    password: options.password,
    salt: options.salt,
    parallelism: options.parallelism,
    iterations: options.iterations,
    memorySize: options.memorySize,
    hashLength: HASH_LENGTH,
    outputType: 'binary',
}));
var Cipher;
(function (Cipher) {
    Cipher["AES128GCM"] = "aes-128-gcm";
})(Cipher = exports.Cipher || (exports.Cipher = {}));
var KDF;
(function (KDF) {
    KDF["ARGON2"] = "argon2id";
    KDF["PBKDF2"] = "PBKDF2";
})(KDF = exports.KDF || (exports.KDF = {}));
const encryptAES128GCMWithPassword = async (plainText, password, options) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const kdf = (_a = options === null || options === void 0 ? void 0 : options.kdf) !== null && _a !== void 0 ? _a : KDF.ARGON2;
    const IV_BUFFER_SIZE = 16;
    const SALT_BUFFER_SIZE = 8;
    const salt = crypto.randomBytes(SALT_BUFFER_SIZE);
    const iv = crypto.randomBytes(IV_BUFFER_SIZE);
    const iterations = (_c = (_b = options === null || options === void 0 ? void 0 : options.kdfparams) === null || _b === void 0 ? void 0 : _b.iterations) !== null && _c !== void 0 ? _c : (kdf === KDF.ARGON2 ? ARGON2_ITERATIONS : (_e = (_d = options === null || options === void 0 ? void 0 : options.kdfparams) === null || _d === void 0 ? void 0 : _d.iterations) !== null && _e !== void 0 ? _e : PBKDF2_ITERATIONS);
    const parallelism = (_g = (_f = options === null || options === void 0 ? void 0 : options.kdfparams) === null || _f === void 0 ? void 0 : _f.parallelism) !== null && _g !== void 0 ? _g : ARGON2_PARALLELISM;
    const memorySize = (_j = (_h = options === null || options === void 0 ? void 0 : options.kdfparams) === null || _h === void 0 ? void 0 : _h.memorySize) !== null && _j !== void 0 ? _j : exports.ARGON2_MEMORY;
    let key;
    if ((options === null || options === void 0 ? void 0 : options.getKey) !== undefined) {
        key = await options.getKey({
            password,
            salt,
            iterations,
            parallelism,
            memorySize,
            hashLength: HASH_LENGTH,
        });
    }
    else if (kdf === KDF.ARGON2) {
        key = await getKeyFromPasswordWithArgon2({
            password,
            salt,
            iterations,
            parallelism,
            memorySize,
        });
    }
    else {
        key = getKeyFromPassword(password, salt, iterations);
    }
    const cipher = crypto.createCipheriv('aes-128-gcm', key.slice(0, 16), iv);
    const firstBlock = Buffer.isBuffer(plainText)
        ? cipher.update(plainText)
        : cipher.update(plainText, 'utf8');
    const encrypted = Buffer.concat([firstBlock, cipher.final()]);
    const tag = cipher.getAuthTag();
    return {
        ciphertext: encrypted.toString('hex'),
        mac: crypto.createHash('sha256').update(key.slice(16, 32)).update(encrypted).digest('hex'),
        kdf,
        kdfparams: {
            parallelism,
            iterations,
            memorySize,
            salt: salt.toString('hex'),
        },
        cipher: Cipher.AES128GCM,
        cipherparams: {
            iv: iv.toString('hex'),
            tag: tag.toString('hex'),
        },
        version: ENCRYPTION_VERSION,
    };
};
exports.encryptAES128GCMWithPassword = encryptAES128GCMWithPassword;
const getTagBuffer = (tag) => {
    const TAG_BUFFER_SIZE = 16;
    const tagBuffer = (0, utils_1.hexToBuffer)(tag, 'Tag');
    if (tagBuffer.length !== TAG_BUFFER_SIZE) {
        throw new Error('Tag must be 16 bytes.');
    }
    return tagBuffer;
};
async function decryptAES128GCMWithPassword(encryptedMessage, password, encoding, options) {
    const { kdf, ciphertext, cipherparams: { iv, tag }, kdfparams: { parallelism, salt, iterations, memorySize }, } = encryptedMessage;
    const tagBuffer = getTagBuffer(tag);
    let key;
    if ((options === null || options === void 0 ? void 0 : options.getKey) !== undefined) {
        key = await options.getKey({
            password,
            salt: (0, utils_1.hexToBuffer)(salt, 'Salt'),
            iterations,
            parallelism,
            memorySize,
            hashLength: HASH_LENGTH,
        });
    }
    else if (kdf === KDF.ARGON2) {
        key = await getKeyFromPasswordWithArgon2({
            password,
            salt: (0, utils_1.hexToBuffer)(salt, 'Salt'),
            iterations,
            parallelism,
            memorySize,
        });
    }
    else {
        key = getKeyFromPassword(password, (0, utils_1.hexToBuffer)(salt, 'Salt'), iterations);
    }
    const decipher = crypto.createDecipheriv('aes-128-gcm', key.slice(0, 16), (0, utils_1.hexToBuffer)(iv, 'IV'));
    decipher.setAuthTag(tagBuffer);
    const firstBlock = decipher.update((0, utils_1.hexToBuffer)(ciphertext, 'Cipher text'));
    const decrypted = Buffer.concat([firstBlock, decipher.final()]);
    if (encoding === 'utf-8' || encoding === 'utf8') {
        return decrypted.toString();
    }
    return decrypted;
}
exports.decryptAES128GCMWithPassword = decryptAES128GCMWithPassword;
exports.encryptMessageWithPassword = exports.encryptAES128GCMWithPassword;
exports.decryptMessageWithPassword = decryptAES128GCMWithPassword;
const parseOption = (optionString) => {
    const option = !optionString ? undefined : parseInt(optionString, 10);
    if (typeof option !== 'undefined' && Number.isNaN(option)) {
        throw new Error('Could not parse option.');
    }
    return option;
};
const parseEncryptedMessage = (encryptedMessage) => {
    var _a, _b, _c;
    if (typeof encryptedMessage !== 'string') {
        throw new Error('Encrypted message to parse must be a string.');
    }
    const keyValuePairs = querystring.parse(encryptedMessage);
    const { kdf, cipher, iterations, salt, ciphertext, iv, tag, version, mac, parallelism, memorySize, } = keyValuePairs;
    if (typeof kdf !== 'string' ||
        typeof cipher !== 'string' ||
        typeof ciphertext !== 'string' ||
        typeof iv !== 'string' ||
        typeof tag !== 'string' ||
        typeof salt !== 'string' ||
        typeof version !== 'string' ||
        typeof mac !== 'string' ||
        (typeof iterations !== 'string' && typeof iterations !== 'undefined') ||
        (typeof parallelism !== 'string' && typeof parallelism !== 'undefined') ||
        (typeof memorySize !== 'string' && typeof memorySize !== 'undefined')) {
        throw new Error('Encrypted message to parse must have only one value per key.');
    }
    const kdfTypes = [KDF.ARGON2, KDF.PBKDF2];
    if (!kdfTypes.includes(kdf)) {
        throw new Error(`KDF must be one of ${kdfTypes.toString()}`);
    }
    const cipherTypes = [Cipher.AES128GCM];
    if (!cipherTypes.includes(cipher)) {
        throw new Error(`Cipher must be one of ${cipherTypes.toString()}`);
    }
    return {
        version,
        ciphertext,
        mac,
        kdf: kdf,
        kdfparams: {
            parallelism: (_a = parseOption(parallelism)) !== null && _a !== void 0 ? _a : ARGON2_PARALLELISM,
            iterations: (_b = parseOption(iterations)) !== null && _b !== void 0 ? _b : ARGON2_ITERATIONS,
            memorySize: (_c = parseOption(memorySize)) !== null && _c !== void 0 ? _c : exports.ARGON2_MEMORY,
            salt,
        },
        cipher: cipher,
        cipherparams: {
            iv,
            tag,
        },
    };
};
exports.parseEncryptedMessage = parseEncryptedMessage;
const stringifyEncryptedMessage = (encryptedMessage) => {
    if (typeof encryptedMessage !== 'object' || encryptedMessage === null) {
        throw new Error('Encrypted message to stringify must be an object.');
    }
    const objectToStringify = {
        kdf: encryptedMessage.kdf,
        cipher: encryptedMessage.cipher,
        version: encryptedMessage.version,
        ciphertext: encryptedMessage.ciphertext,
        mac: encryptedMessage.mac,
        salt: encryptedMessage.kdfparams.salt,
        iv: encryptedMessage.cipherparams.iv,
        tag: encryptedMessage.cipherparams.tag,
        iterations: encryptedMessage.kdfparams.iterations,
        parallelism: encryptedMessage.kdfparams.parallelism,
        memorySize: encryptedMessage.kdfparams.memorySize,
    };
    return querystring.stringify(objectToStringify);
};
exports.stringifyEncryptedMessage = stringifyEncryptedMessage;
//# sourceMappingURL=encrypt.js.map