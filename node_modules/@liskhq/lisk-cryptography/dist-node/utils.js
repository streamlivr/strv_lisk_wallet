"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRandomBytes = exports.hashOnion = exports.generateHashOnionSeed = exports.hexToBuffer = exports.intToBuffer = exports.LITTLE_ENDIAN = exports.BIG_ENDIAN = exports.tagMessage = exports.createMessageTag = exports.parseKeyDerivationPath = exports.hash = void 0;
const crypto = require("crypto");
const constants_1 = require("./constants");
const nacl_1 = require("./nacl");
Object.defineProperty(exports, "getRandomBytes", { enumerable: true, get: function () { return nacl_1.getRandomBytes; } });
const cryptoHashSha256 = (data) => {
    const dataHash = crypto.createHash('sha256');
    dataHash.update(data);
    return dataHash.digest();
};
const hash = (data, format) => {
    if (Buffer.isBuffer(data)) {
        return cryptoHashSha256(data);
    }
    if (typeof data === 'string' && typeof format === 'string') {
        if (!['utf8', 'hex'].includes(format)) {
            throw new Error('Unsupported string format. Currently only `hex` and `utf8` are supported.');
        }
        const encoded = format === 'utf8' ? Buffer.from(data, 'utf8') : Buffer.from(data, 'hex');
        return cryptoHashSha256(encoded);
    }
    throw new Error(`Unsupported data:${data} and format:${format !== null && format !== void 0 ? format : 'undefined'}. Currently only Buffers or hex and utf8 strings are supported.`);
};
exports.hash = hash;
const parseKeyDerivationPath = (path) => {
    if (!path.startsWith('m') || !path.includes('/')) {
        throw new Error('Invalid key derivation path format');
    }
    return (path
        .split('/')
        .slice(1)
        .map(segment => {
        if (!/^[0-9']+$/g.test(segment)) {
            throw new Error('Invalid key derivation path format');
        }
        if (segment.includes(`'`)) {
            if (parseInt(segment.slice(0, -1), 10) > constants_1.MAX_UINT32 / 2) {
                throw new Error('Invalid key derivation path format');
            }
            return parseInt(segment, 10) + constants_1.HARDENED_OFFSET;
        }
        if (parseInt(segment, 10) > constants_1.MAX_UINT32) {
            throw new Error('Invalid key derivation path format');
        }
        return parseInt(segment, 10);
    }));
};
exports.parseKeyDerivationPath = parseKeyDerivationPath;
const TAG_REGEX = /^([A-Za-z0-9])+$/;
const createMessageTag = (domain, version) => {
    if (!TAG_REGEX.test(domain)) {
        throw new Error(`Message tag domain must be alpha numeric without special characters. Got "${domain}".`);
    }
    if (version && !TAG_REGEX.test(version.toString())) {
        throw new Error(`Message tag version must be alpha numeric without special characters. Got "${version}"`);
    }
    return `LSK_${version ? `${domain}:${version}` : domain}_`;
};
exports.createMessageTag = createMessageTag;
const tagMessage = (tag, chainID, message) => Buffer.concat([
    Buffer.from(tag, 'utf8'),
    chainID,
    typeof message === 'string' ? Buffer.from(message, 'utf8') : message,
]);
exports.tagMessage = tagMessage;
exports.BIG_ENDIAN = 'big';
exports.LITTLE_ENDIAN = 'little';
const MAX_NUMBER_BYTE_LENGTH = 6;
const intToBuffer = (value, byteLength, endianness = exports.BIG_ENDIAN, signed = false) => {
    if (![exports.BIG_ENDIAN, exports.LITTLE_ENDIAN].includes(endianness)) {
        throw new Error(`Endianness must be either ${exports.BIG_ENDIAN} or ${exports.LITTLE_ENDIAN}`);
    }
    const buffer = Buffer.alloc(byteLength);
    if (endianness === 'big') {
        if (byteLength <= MAX_NUMBER_BYTE_LENGTH) {
            if (signed) {
                buffer.writeIntBE(Number(value), 0, byteLength);
            }
            else {
                buffer.writeUIntBE(Number(value), 0, byteLength);
            }
        }
        else {
            if (signed) {
                buffer.writeBigInt64BE(BigInt(value));
            }
            else {
                buffer.writeBigUInt64BE(BigInt(value));
            }
        }
    }
    else {
        if (byteLength <= MAX_NUMBER_BYTE_LENGTH) {
            if (signed) {
                buffer.writeIntLE(Number(value), 0, byteLength);
            }
            else {
                buffer.writeUIntLE(Number(value), 0, byteLength);
            }
        }
        else {
            if (signed) {
                buffer.writeBigInt64LE(BigInt(value));
            }
            else {
                buffer.writeBigUInt64LE(BigInt(value));
            }
        }
    }
    return buffer;
};
exports.intToBuffer = intToBuffer;
const hexRegex = /^[0-9a-f]+/i;
const hexToBuffer = (hex, argumentName = 'Argument') => {
    var _a;
    if (typeof hex !== 'string') {
        throw new TypeError(`${argumentName} must be a string.`);
    }
    const matchedHex = ((_a = hex.match(hexRegex)) !== null && _a !== void 0 ? _a : [])[0];
    if (!matchedHex || matchedHex.length !== hex.length) {
        throw new TypeError(`${argumentName} must be a valid hex string.`);
    }
    if (matchedHex.length % 2 !== 0) {
        throw new TypeError(`${argumentName} must have a valid length of hex string.`);
    }
    return Buffer.from(matchedHex, 'hex');
};
exports.hexToBuffer = hexToBuffer;
const HASH_SIZE = 16;
const INPUT_SIZE = 64;
const defaultCount = 1000000;
const defaultDistance = 1000;
const generateHashOnionSeed = () => (0, exports.hash)((0, nacl_1.getRandomBytes)(INPUT_SIZE)).slice(0, HASH_SIZE);
exports.generateHashOnionSeed = generateHashOnionSeed;
const hashOnion = (seed, count = defaultCount, distance = defaultDistance) => {
    if (count < distance) {
        throw new Error('Invalid count or distance. Count must be greater than distance');
    }
    if (count % distance !== 0) {
        throw new Error('Invalid count. Count must be multiple of distance');
    }
    let previousHash = seed;
    const hashes = [seed];
    for (let i = 1; i <= count; i += 1) {
        const nextHash = (0, exports.hash)(previousHash).slice(0, HASH_SIZE);
        if (i % distance === 0) {
            hashes.push(nextHash);
        }
        previousHash = nextHash;
    }
    return hashes.reverse();
};
exports.hashOnion = hashOnion;
//# sourceMappingURL=utils.js.map