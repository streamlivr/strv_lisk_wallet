"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyData = exports.signData = exports.signDataWithPrivateKey = exports.signAndPrintMessage = exports.printSignedMessage = exports.verifyMessageWithPublicKey = exports.signMessageWithPrivateKey = exports.getPrivateKeyFromPhraseAndPath = exports.getPublicKeyFromPrivateKey = void 0;
const crypto = require("crypto");
const lisk_passphrase_1 = require("@liskhq/lisk-passphrase");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const nacl_1 = require("./nacl");
const createHeader = (text) => `-----${text}-----`;
const signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');
const messageHeader = createHeader('MESSAGE');
const publicKeyHeader = createHeader('PUBLIC KEY');
const signatureHeader = createHeader('SIGNATURE');
const signatureFooter = createHeader('END LISK SIGNED MESSAGE');
const getPublicKeyFromPrivateKey = (pk) => (0, nacl_1.getPublicKey)(pk);
exports.getPublicKeyFromPrivateKey = getPublicKeyFromPrivateKey;
const getMasterKeyFromSeed = (seed) => {
    const hmac = crypto.createHmac('sha512', constants_1.ED25519_CURVE);
    const digest = hmac.update(seed).digest();
    const leftBytes = digest.slice(0, 32);
    const rightBytes = digest.slice(32);
    return {
        key: leftBytes,
        chainCode: rightBytes,
    };
};
const getChildKey = (node, index) => {
    const indexBuffer = Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(index, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), node.key, indexBuffer]);
    const digest = crypto.createHmac('sha512', node.chainCode).update(data).digest();
    const leftBytes = digest.slice(0, 32);
    const rightBytes = digest.slice(32);
    return {
        key: leftBytes,
        chainCode: rightBytes,
    };
};
const getPrivateKeyFromPhraseAndPath = async (phrase, path) => {
    const masterSeed = await lisk_passphrase_1.Mnemonic.mnemonicToSeed(phrase);
    let node = getMasterKeyFromSeed(masterSeed);
    for (const segment of (0, utils_1.parseKeyDerivationPath)(path)) {
        node = getChildKey(node, segment);
    }
    return (0, nacl_1.getKeyPair)(node.key).privateKey;
};
exports.getPrivateKeyFromPhraseAndPath = getPrivateKeyFromPhraseAndPath;
const signMessageWithPrivateKey = (message, privateKey, tag = constants_1.MESSAGE_TAG_NON_PROTOCOL_MESSAGE) => {
    const messageBuffer = typeof message === 'string' ? Buffer.from(message, 'utf8') : message;
    const publicKey = (0, nacl_1.getPublicKey)(privateKey);
    const signature = (0, exports.signDataWithPrivateKey)(tag, constants_1.EMPTY_BUFFER, messageBuffer, privateKey);
    return {
        message,
        publicKey,
        signature,
    };
};
exports.signMessageWithPrivateKey = signMessageWithPrivateKey;
const verifyMessageWithPublicKey = ({ message, publicKey, signature, tag = constants_1.MESSAGE_TAG_NON_PROTOCOL_MESSAGE, }) => {
    if (publicKey.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {
        throw new Error(`Invalid publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH}-byte publicKey`);
    }
    if (signature.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {
        throw new Error(`Invalid signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH}-byte signature`);
    }
    const messageBuffer = typeof message === 'string' ? Buffer.from(message, 'utf8') : message;
    return (0, exports.verifyData)(tag, constants_1.EMPTY_BUFFER, messageBuffer, signature, publicKey);
};
exports.verifyMessageWithPublicKey = verifyMessageWithPublicKey;
const printSignedMessage = ({ message, signature, publicKey }) => [
    signedMessageHeader,
    messageHeader,
    typeof message === 'string' ? message : message.toString('hex'),
    publicKeyHeader,
    publicKey.toString('hex'),
    signatureHeader,
    signature.toString('hex'),
    signatureFooter,
]
    .filter(Boolean)
    .join('\n');
exports.printSignedMessage = printSignedMessage;
const signAndPrintMessage = (message, privateKey) => {
    const signedMessage = (0, exports.signMessageWithPrivateKey)(message, privateKey);
    return (0, exports.printSignedMessage)(signedMessage);
};
exports.signAndPrintMessage = signAndPrintMessage;
const signDataWithPrivateKey = (tag, chainID, data, privateKey) => (0, nacl_1.signDetached)((0, utils_1.hash)((0, utils_1.tagMessage)(tag, chainID, data)), privateKey);
exports.signDataWithPrivateKey = signDataWithPrivateKey;
exports.signData = exports.signDataWithPrivateKey;
const verifyData = (tag, chainID, data, signature, publicKey) => (0, nacl_1.verifyDetached)((0, utils_1.hash)((0, utils_1.tagMessage)(tag, chainID, data)), signature, publicKey);
exports.verifyData = verifyData;
//# sourceMappingURL=ed.js.map